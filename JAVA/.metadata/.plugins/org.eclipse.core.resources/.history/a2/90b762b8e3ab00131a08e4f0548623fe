package sorting2014;

@SuppressWarnings("rawtypes")
public class ReverseSorter implements Sorter {

	@Override
	public void sort(Comparable[] items, int cutoff) {

		 quicksort(items, 0, items.length - 1);

	}

	 
	private void quicksort(Comparable[] items, int first, int last) {

		int arrSize = last - first + 1; // determine the (sub)array's size

		if (arrSize < 2) {
			return; // if only one item in the array - it is sorted
		} 

		int pivot = first + ((last - first) / 2); // the pivot index - the middle element

		pivot = parition(items, first, last, pivot); // moves the pivot to it's correct position 

		quicksort(items, first, pivot - 1); // recursively sort the sub array left from the pivot
		
		quicksort(items, pivot + 1, last); // recursively sort the sub array right from the pivot

	}

	 
	private int parition(Comparable[] items, int left, int right, int pivotIndex) {

		swap(items, pivotIndex, left); // move the pivot out of the way

		int swap = left + 1; // set the initial swap position

		for (int i = swap; i <= right; i++) { // loop through swap until right(inclusive)

			if (items[left].compareTo(items[i]) < 0) { // compare the current item with the pivot

				swap(items, swap, i); // swap the current item with the swap position
				swap++; // move the swap position to the right
			}

		}
		swap(items, left, swap - 1); // put the pivot to it's right place
		return swap - 1; // swap - 1 is the pivot's new index

	}

	 
	private void swap(Comparable[] items, int indexFirst, int secondSecond) {

		Comparable temp = items[indexFirst]; // store the first in temporary variable

		items[indexFirst] = items[secondSecond]; // change the first to the second's value

		items[secondSecond] = temp; // change the second to the first's value

	}

}
