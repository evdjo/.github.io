package abstractDataTypes;

public class AVLTree<T extends Comparable<? super T>> {

	 private static class AVLNode<T>{

		 
		 AVLNode<T>        left;
		 AVLNode<T>        right;
		 T                 data;
		 int               height;
		 AVLNode(T data){
			 this(data,null,null);
			 
		 }
		 AVLNode(T data,AVLNode<T> left,AVLNode<T> right){
			 this.left   =     left;   // the left child
			 this.right  =     right;  // the right child
			 this.data   =     data;   // the data stored in the node
			 this.height =     0;      // the Height
		 }
	 }

	 
	 private AVLNode<T> root;
	 
	 public void insert(T data) {
		 root = this.insert(root, data);
		  
	 }
	 private AVLNode<T> insert(AVLNode<T> parent,T data){
		 if(parent == null) { return new AVLNode<>(data,null,null); }  // base case 
		 
		 int comparison = data.compareTo(parent.data);
		 
		 if      ( comparison < 0 )  { parent.left   =  insert ( parent.left,  data ); }
		 
		 else if ( comparison > 0 )  { parent.right  =  insert ( parent.right, data ); }
		 
		 else {  }
		 
		 return balanceToTheForce(parent);
	 }
	 private AVLNode<T> balanceToTheForce(AVLNode<T> root) {
		 
		 if(root == null) { return root; }
		 
		 if( getHeight(root.left) - getHeight(root.right) > 1 ) {  // determine if left is higher than the right
			 if(getHeight(root.left.left) >= getHeight(root.left.right)  ) {
				root = this.singleRotateLeft(root);
			} else {
				root = this.DoubleRotateLeft(root);
			}
		 }
		 
		 
		 return null;
	 }
	 
	 private AVLNode<T> DoubleRotateLeft(AVLNode<T> root) {
		 
		return null;
	}
	private int getHeight(AVLNode<T> node) {
		 
		 return node == null ? -1 : node.height ;
	 }
	 private AVLNode<T> singleRotateLeft(AVLNode<T> root) {
		 return null;
	 }
	 
}
		